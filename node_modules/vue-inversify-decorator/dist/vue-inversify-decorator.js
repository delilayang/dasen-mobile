/*!
 * vue-inversify-decorator v0.1.0
 * https://github.com/ktsn/vue-inversify-decorator
 *
 * @license
 * Copyright (c) 2017 katashin
 * Released under the MIT license
 * https://github.com/ktsn/vue-inversify-decorator/blob/master/LICENSE
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue-class-component')) :
	typeof define === 'function' && define.amd ? define(['exports', 'vue-class-component'], factory) :
	(factory((global.VueInversifyDecorator = {}),global.vueClassComponent));
}(this, (function (exports,vueClassComponent) { 'use strict';

var containerKey = '__inversify_container__';
var Provide = function (container) { return vueClassComponent.createDecorator(function (options) {
    options.mixins = options.mixins || [];
    options.mixins.push({
        provide: (_a = {},
            _a[containerKey] = container,
            _a)
    });
    var _a;
}); };
var Inject = function (identifier) { return function (proto, key) {
    var Type;
    if (typeof Reflect !== 'undefined' && typeof Reflect.getMetadata === 'function') {
        Type = Reflect.getMetadata('design:type', proto, key);
    }
    return vueClassComponent.createDecorator(function (options, key) {
        if (!options.__container_injected__) {
            options.mixins = options.mixins || [];
            options.mixins.push({
                inject: [containerKey]
            });
            options.__container_injected__ = true;
        }
        options.computed = options.computed || {};
        options.computed[key] = function () {
            return this[containerKey].get(identifier || Type);
        };
    })(proto, key);
}; };

exports.Provide = Provide;
exports.Inject = Inject;

Object.defineProperty(exports, '__esModule', { value: true });

})));
